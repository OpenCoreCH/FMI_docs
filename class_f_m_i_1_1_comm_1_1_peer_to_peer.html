<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FMI: FMI::Comm::PeerToPeer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FMI<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">FaaS Message Interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_f_m_i.html">FMI</a></li><li class="navelem"><a class="el" href="namespace_f_m_i_1_1_comm.html">Comm</a></li><li class="navelem"><a class="el" href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html">PeerToPeer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_f_m_i_1_1_comm_1_1_peer_to_peer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">FMI::Comm::PeerToPeer Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Peer-To-Peer channel type.  
 <a href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_peer_to_peer_8h_source.html">PeerToPeer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FMI::Comm::PeerToPeer:</div>
<div class="dyncontent">
<div class="center"><img src="class_f_m_i_1_1_comm_1_1_peer_to_peer__inherit__graph.png" border="0" usemap="#a_f_m_i_1_1_comm_1_1_peer_to_peer_inherit__map" alt="Inheritance graph"/></div>
<map name="a_f_m_i_1_1_comm_1_1_peer_to_peer_inherit__map" id="a_f_m_i_1_1_comm_1_1_peer_to_peer_inherit__map">
<area shape="rect" title="Peer&#45;To&#45;Peer channel type." alt="" coords="5,321,175,648"/>
<area shape="rect" href="class_f_m_i_1_1_comm_1_1_direct.html" title="Channel that uses the TCPunch TCP NAT Hole Punching Library for connection establishment." alt="" coords="23,696,157,832"/>
<area shape="rect" href="class_f_m_i_1_1_comm_1_1_channel.html" title="Interface that defines channel operations. Only provides a few default implementations,..." alt="" coords="16,5,164,273"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for FMI::Comm::PeerToPeer:</div>
<div class="dyncontent">
<div class="center"><img src="class_f_m_i_1_1_comm_1_1_peer_to_peer__coll__graph.png" border="0" usemap="#a_f_m_i_1_1_comm_1_1_peer_to_peer_coll__map" alt="Collaboration graph"/></div>
<map name="a_f_m_i_1_1_comm_1_1_peer_to_peer_coll__map" id="a_f_m_i_1_1_comm_1_1_peer_to_peer_coll__map">
<area shape="rect" title="Peer&#45;To&#45;Peer channel type." alt="" coords="20,448,189,775"/>
<area shape="rect" href="class_f_m_i_1_1_comm_1_1_channel.html" title="Interface that defines channel operations. Only provides a few default implementations,..." alt="" coords="31,160,179,399"/>
<area shape="rect" title=" " alt="" coords="5,5,97,83"/>
<area shape="rect" title=" " alt="" coords="131,5,185,83"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a82903e6459ffa1ccf71af2cc67ca977f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a82903e6459ffa1ccf71af2cc67ca977f">send</a> (<a class="el" href="structchannel__data.html">channel_data</a> buf, <a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">FMI::Utils::peer_num</a> dest) override</td></tr>
<tr class="memdesc:a82903e6459ffa1ccf71af2cc67ca977f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to peer with id dest, must match a recv call.  <a href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a82903e6459ffa1ccf71af2cc67ca977f">More...</a><br /></td></tr>
<tr class="separator:a82903e6459ffa1ccf71af2cc67ca977f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d28eb8d914a5598f11f829a0812c09f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a1d28eb8d914a5598f11f829a0812c09f">recv</a> (<a class="el" href="structchannel__data.html">channel_data</a> buf, <a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">FMI::Utils::peer_num</a> src) override</td></tr>
<tr class="memdesc:a1d28eb8d914a5598f11f829a0812c09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data from peer with id src, must match a send call.  <a href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a1d28eb8d914a5598f11f829a0812c09f">More...</a><br /></td></tr>
<tr class="separator:a1d28eb8d914a5598f11f829a0812c09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebfb93838072c441366cf33969b4345"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a7ebfb93838072c441366cf33969b4345">bcast</a> (<a class="el" href="structchannel__data.html">channel_data</a> buf, <a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">FMI::Utils::peer_num</a> root) override</td></tr>
<tr class="memdesc:a7ebfb93838072c441366cf33969b4345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binomial tree broadcast implementation.  <a href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a7ebfb93838072c441366cf33969b4345">More...</a><br /></td></tr>
<tr class="separator:a7ebfb93838072c441366cf33969b4345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20938de637594812abb4831ca0a4a412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a20938de637594812abb4831ca0a4a412">barrier</a> () override</td></tr>
<tr class="memdesc:a20938de637594812abb4831ca0a4a412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls allreduce with a (associative and commutative) NOP operation.  <a href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a20938de637594812abb4831ca0a4a412">More...</a><br /></td></tr>
<tr class="separator:a20938de637594812abb4831ca0a4a412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdac4f4b23f1be105e3caf3f8bbae8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a7bdac4f4b23f1be105e3caf3f8bbae8d">gather</a> (<a class="el" href="structchannel__data.html">channel_data</a> sendbuf, <a class="el" href="structchannel__data.html">channel_data</a> recvbuf, <a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">FMI::Utils::peer_num</a> root) override</td></tr>
<tr class="memdesc:a7bdac4f4b23f1be105e3caf3f8bbae8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binomial tree gather.  <a href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a7bdac4f4b23f1be105e3caf3f8bbae8d">More...</a><br /></td></tr>
<tr class="separator:a7bdac4f4b23f1be105e3caf3f8bbae8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db2dfcf52658225c8539de30da0321f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a2db2dfcf52658225c8539de30da0321f">scatter</a> (<a class="el" href="structchannel__data.html">channel_data</a> sendbuf, <a class="el" href="structchannel__data.html">channel_data</a> recvbuf, <a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">FMI::Utils::peer_num</a> root) override</td></tr>
<tr class="memdesc:a2db2dfcf52658225c8539de30da0321f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binomial tree scatter.  <a href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a2db2dfcf52658225c8539de30da0321f">More...</a><br /></td></tr>
<tr class="separator:a2db2dfcf52658225c8539de30da0321f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5964edc9ddf7e3b3586f5c79cf9bc317"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a5964edc9ddf7e3b3586f5c79cf9bc317">reduce</a> (<a class="el" href="structchannel__data.html">channel_data</a> sendbuf, <a class="el" href="structchannel__data.html">channel_data</a> recvbuf, <a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">FMI::Utils::peer_num</a> root, <a class="el" href="structraw__function.html">raw_function</a> f) override</td></tr>
<tr class="memdesc:a5964edc9ddf7e3b3586f5c79cf9bc317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls reduce_no_order for associative and commutative functions, reduce_ltr otherwise.  <a href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a5964edc9ddf7e3b3586f5c79cf9bc317">More...</a><br /></td></tr>
<tr class="separator:a5964edc9ddf7e3b3586f5c79cf9bc317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079ff911438fe4e6f426998fe433b63e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a079ff911438fe4e6f426998fe433b63e">allreduce</a> (<a class="el" href="structchannel__data.html">channel_data</a> sendbuf, <a class="el" href="structchannel__data.html">channel_data</a> recvbuf, <a class="el" href="structraw__function.html">raw_function</a> f) override</td></tr>
<tr class="memdesc:a079ff911438fe4e6f426998fe433b63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For associative and commutative functions, allreduce_no_order is called. Otherwise, reduce followed by bcast is used.  <a href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a079ff911438fe4e6f426998fe433b63e">More...</a><br /></td></tr>
<tr class="separator:a079ff911438fe4e6f426998fe433b63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54911802d94b2913ac2d2f1c970e498d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a54911802d94b2913ac2d2f1c970e498d">scan</a> (<a class="el" href="structchannel__data.html">channel_data</a> sendbuf, <a class="el" href="structchannel__data.html">channel_data</a> recvbuf, <a class="el" href="structraw__function.html">raw_function</a> f) override</td></tr>
<tr class="memdesc:a54911802d94b2913ac2d2f1c970e498d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For associative and commutative functions, scan_no_order is called. Otherwise, scan_ltr is called.  <a href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a54911802d94b2913ac2d2f1c970e498d">More...</a><br /></td></tr>
<tr class="separator:a54911802d94b2913ac2d2f1c970e498d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334549eda175c0ca0e5f7abbd45d7f1e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a334549eda175c0ca0e5f7abbd45d7f1e">send_object</a> (<a class="el" href="structchannel__data.html">channel_data</a> buf, <a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">Utils::peer_num</a> <a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#a9f7d4051adac684c765aeb78891d6f02">peer_id</a>)=0</td></tr>
<tr class="memdesc:a334549eda175c0ca0e5f7abbd45d7f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an object to peer with ID peer_id. Needs to be implemented by the channels.  <a href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a334549eda175c0ca0e5f7abbd45d7f1e">More...</a><br /></td></tr>
<tr class="separator:a334549eda175c0ca0e5f7abbd45d7f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb95fe6dec31fecd90869e03c97b3698"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#acb95fe6dec31fecd90869e03c97b3698">recv_object</a> (<a class="el" href="structchannel__data.html">channel_data</a> buf, <a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">Utils::peer_num</a> <a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#a9f7d4051adac684c765aeb78891d6f02">peer_id</a>)=0</td></tr>
<tr class="memdesc:acb95fe6dec31fecd90869e03c97b3698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive an object from peer with ID peer_id. Needs to be implemented by the channels.  <a href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#acb95fe6dec31fecd90869e03c97b3698">More...</a><br /></td></tr>
<tr class="separator:acb95fe6dec31fecd90869e03c97b3698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ebd572a8f14ee6335bf684bf121473"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a00ebd572a8f14ee6335bf684bf121473">get_operation_latency</a> (<a class="el" href="struct_f_m_i_1_1_utils_1_1_operation_info.html">Utils::OperationInfo</a> op_info) override</td></tr>
<tr class="memdesc:a00ebd572a8f14ee6335bf684bf121473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performance model for collective operations, provides the latency for the given operation.  <a href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a00ebd572a8f14ee6335bf684bf121473">More...</a><br /></td></tr>
<tr class="separator:a00ebd572a8f14ee6335bf684bf121473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93c5dde9ef79fbc03980fd883239e9b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#ab93c5dde9ef79fbc03980fd883239e9b">get_operation_price</a> (<a class="el" href="struct_f_m_i_1_1_utils_1_1_operation_info.html">Utils::OperationInfo</a> op_info) override</td></tr>
<tr class="memdesc:ab93c5dde9ef79fbc03980fd883239e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost model for collective operations, provides the price for the given operation.  <a href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#ab93c5dde9ef79fbc03980fd883239e9b">More...</a><br /></td></tr>
<tr class="separator:ab93c5dde9ef79fbc03980fd883239e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_f_m_i_1_1_comm_1_1_channel"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_f_m_i_1_1_comm_1_1_channel')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html">FMI::Comm::Channel</a></td></tr>
<tr class="memitem:a0f3c34fdfba814b33e2f44c359037714 inherit pub_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#a0f3c34fdfba814b33e2f44c359037714">set_peer_id</a> (<a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">FMI::Utils::peer_num</a> num)</td></tr>
<tr class="memdesc:a0f3c34fdfba814b33e2f44c359037714 inherit pub_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to set peer id, ID needs to be set before first collective operation.  <a href="class_f_m_i_1_1_comm_1_1_channel.html#a0f3c34fdfba814b33e2f44c359037714">More...</a><br /></td></tr>
<tr class="separator:a0f3c34fdfba814b33e2f44c359037714 inherit pub_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bb5e34677e3a0b2f7daf008144f181 inherit pub_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#af5bb5e34677e3a0b2f7daf008144f181">set_num_peers</a> (<a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">FMI::Utils::peer_num</a> num)</td></tr>
<tr class="memdesc:af5bb5e34677e3a0b2f7daf008144f181 inherit pub_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to set number of peers, needs to be set before first collective operation.  <a href="class_f_m_i_1_1_comm_1_1_channel.html#af5bb5e34677e3a0b2f7daf008144f181">More...</a><br /></td></tr>
<tr class="separator:af5bb5e34677e3a0b2f7daf008144f181 inherit pub_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2197bde7ee7f214d10472a2d935e29 inherit pub_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#adc2197bde7ee7f214d10472a2d935e29">set_comm_name</a> (std::string communication_name)</td></tr>
<tr class="memdesc:adc2197bde7ee7f214d10472a2d935e29 inherit pub_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to set the communicator name, should be set before first collective operation to avoid conflicts with empty communicator name.  <a href="class_f_m_i_1_1_comm_1_1_channel.html#adc2197bde7ee7f214d10472a2d935e29">More...</a><br /></td></tr>
<tr class="separator:adc2197bde7ee7f214d10472a2d935e29 inherit pub_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8bcfa9ba7e098134f14f2d57edd6c05 inherit pub_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#ae8bcfa9ba7e098134f14f2d57edd6c05">finalize</a> ()</td></tr>
<tr class="memdesc:ae8bcfa9ba7e098134f14f2d57edd6c05 inherit pub_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before communicator is destructed, can be used by channels to clean up (e.g., delete resources)  <a href="class_f_m_i_1_1_comm_1_1_channel.html#ae8bcfa9ba7e098134f14f2d57edd6c05">More...</a><br /></td></tr>
<tr class="separator:ae8bcfa9ba7e098134f14f2d57edd6c05 inherit pub_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b68510858c446365188ccd6777a1c6 inherit pub_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#ab1b68510858c446365188ccd6777a1c6">get_latency</a> (<a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">Utils::peer_num</a> producer, <a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">Utils::peer_num</a> consumer, std::size_t size_in_bytes)=0</td></tr>
<tr class="memdesc:ab1b68510858c446365188ccd6777a1c6 inherit pub_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performance model of an individual channel, provides latency for a simple exchange with a number of producers / consumers.  <a href="class_f_m_i_1_1_comm_1_1_channel.html#ab1b68510858c446365188ccd6777a1c6">More...</a><br /></td></tr>
<tr class="separator:ab1b68510858c446365188ccd6777a1c6 inherit pub_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb96d9d13209f68bd727f6e825092b54 inherit pub_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#afb96d9d13209f68bd727f6e825092b54">get_price</a> (<a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">Utils::peer_num</a> producer, <a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">Utils::peer_num</a> consumer, std::size_t size_in_bytes)=0</td></tr>
<tr class="memdesc:afb96d9d13209f68bd727f6e825092b54 inherit pub_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost model of an individual channel, provides price for a simple exchange with a number of producers / consumers.  <a href="class_f_m_i_1_1_comm_1_1_channel.html#afb96d9d13209f68bd727f6e825092b54">More...</a><br /></td></tr>
<tr class="separator:afb96d9d13209f68bd727f6e825092b54 inherit pub_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4d05f0a04be2d7dcb966ea7714e1c243"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a4d05f0a04be2d7dcb966ea7714e1c243">reduce_ltr</a> (<a class="el" href="structchannel__data.html">channel_data</a> sendbuf, <a class="el" href="structchannel__data.html">channel_data</a> recvbuf, <a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">FMI::Utils::peer_num</a> root, const <a class="el" href="structraw__function.html">raw_function</a> &amp;f)</td></tr>
<tr class="memdesc:a4d05f0a04be2d7dcb966ea7714e1c243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduction with left-to-right evaluation, gather followed by a function evaluation on the root peer.  <a href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a4d05f0a04be2d7dcb966ea7714e1c243">More...</a><br /></td></tr>
<tr class="separator:a4d05f0a04be2d7dcb966ea7714e1c243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4869c382734a078c1c357536bee3f114"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a4869c382734a078c1c357536bee3f114">reduce_no_order</a> (<a class="el" href="structchannel__data.html">channel_data</a> sendbuf, <a class="el" href="structchannel__data.html">channel_data</a> recvbuf, <a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">FMI::Utils::peer_num</a> root, const <a class="el" href="structraw__function.html">raw_function</a> &amp;f)</td></tr>
<tr class="memdesc:a4869c382734a078c1c357536bee3f114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binomial tree reduction where all peers apply the function in every step.  <a href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a4869c382734a078c1c357536bee3f114">More...</a><br /></td></tr>
<tr class="separator:a4869c382734a078c1c357536bee3f114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716d175a63e30ac982b85ea494e7b788"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a716d175a63e30ac982b85ea494e7b788">allreduce_no_order</a> (<a class="el" href="structchannel__data.html">channel_data</a> sendbuf, <a class="el" href="structchannel__data.html">channel_data</a> recvbuf, const <a class="el" href="structraw__function.html">raw_function</a> &amp;f)</td></tr>
<tr class="memdesc:a716d175a63e30ac982b85ea494e7b788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive doubling allreduce implementation. When num_peers is not a power of two, there is an additional message in the beginning and end for every peer where they send their value / receive the reduced value.  <a href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a716d175a63e30ac982b85ea494e7b788">More...</a><br /></td></tr>
<tr class="separator:a716d175a63e30ac982b85ea494e7b788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa110a201850ceabf4959fe77d0ec4a10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#aa110a201850ceabf4959fe77d0ec4a10">scan_ltr</a> (<a class="el" href="structchannel__data.html">channel_data</a> sendbuf, <a class="el" href="structchannel__data.html">channel_data</a> recvbuf, const <a class="el" href="structraw__function.html">raw_function</a> &amp;f)</td></tr>
<tr class="memdesc:aa110a201850ceabf4959fe77d0ec4a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear function application / sending.  <a href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#aa110a201850ceabf4959fe77d0ec4a10">More...</a><br /></td></tr>
<tr class="separator:aa110a201850ceabf4959fe77d0ec4a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a05ba40632ffc2328e9a01a33e7f373"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a5a05ba40632ffc2328e9a01a33e7f373">scan_no_order</a> (<a class="el" href="structchannel__data.html">channel_data</a> sendbuf, <a class="el" href="structchannel__data.html">channel_data</a> recvbuf, const <a class="el" href="structraw__function.html">raw_function</a> &amp;f)</td></tr>
<tr class="memdesc:a5a05ba40632ffc2328e9a01a33e7f373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binomial tree with up- and down-phase.  <a href="class_f_m_i_1_1_comm_1_1_peer_to_peer.html#a5a05ba40632ffc2328e9a01a33e7f373">More...</a><br /></td></tr>
<tr class="separator:a5a05ba40632ffc2328e9a01a33e7f373"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_class_f_m_i_1_1_comm_1_1_channel"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_f_m_i_1_1_comm_1_1_channel')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html">FMI::Comm::Channel</a></td></tr>
<tr class="memitem:abf4639c7a95d639ad280b8c16ea32627 inherit pub_static_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html">Channel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#abf4639c7a95d639ad280b8c16ea32627">get_channel</a> (std::string name, std::map&lt; std::string, std::string &gt; params, std::map&lt; std::string, std::string &gt; model_params)</td></tr>
<tr class="memdesc:abf4639c7a95d639ad280b8c16ea32627 inherit pub_static_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new channel with the given config and model params.  <a href="class_f_m_i_1_1_comm_1_1_channel.html#abf4639c7a95d639ad280b8c16ea32627">More...</a><br /></td></tr>
<tr class="separator:abf4639c7a95d639ad280b8c16ea32627 inherit pub_static_methods_class_f_m_i_1_1_comm_1_1_channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_f_m_i_1_1_comm_1_1_channel"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_f_m_i_1_1_comm_1_1_channel')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html">FMI::Comm::Channel</a></td></tr>
<tr class="memitem:a9f7d4051adac684c765aeb78891d6f02 inherit pro_attribs_class_f_m_i_1_1_comm_1_1_channel"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">FMI::Utils::peer_num</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#a9f7d4051adac684c765aeb78891d6f02">peer_id</a></td></tr>
<tr class="separator:a9f7d4051adac684c765aeb78891d6f02 inherit pro_attribs_class_f_m_i_1_1_comm_1_1_channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c66ef938dfd582c349375874d5146a8 inherit pro_attribs_class_f_m_i_1_1_comm_1_1_channel"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">FMI::Utils::peer_num</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#a8c66ef938dfd582c349375874d5146a8">num_peers</a></td></tr>
<tr class="separator:a8c66ef938dfd582c349375874d5146a8 inherit pro_attribs_class_f_m_i_1_1_comm_1_1_channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb641d1af2ef083c9b40dcaa19930498 inherit pro_attribs_class_f_m_i_1_1_comm_1_1_channel"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#aeb641d1af2ef083c9b40dcaa19930498">comm_name</a></td></tr>
<tr class="memdesc:aeb641d1af2ef083c9b40dcaa19930498 inherit pro_attribs_class_f_m_i_1_1_comm_1_1_channel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can optionally be used by channels to avoid resource conflicts that may occur because of multiple concurrent communicators.  <a href="class_f_m_i_1_1_comm_1_1_channel.html#aeb641d1af2ef083c9b40dcaa19930498">More...</a><br /></td></tr>
<tr class="separator:aeb641d1af2ef083c9b40dcaa19930498 inherit pro_attribs_class_f_m_i_1_1_comm_1_1_channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Peer-To-Peer channel type. </p>
<p >This class provides optimized collectives for channels where clients can address each other directly and defines the interface that these channels need to implement. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a079ff911438fe4e6f426998fe433b63e" name="a079ff911438fe4e6f426998fe433b63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079ff911438fe4e6f426998fe433b63e">&#9670;&nbsp;</a></span>allreduce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FMI::Comm::PeerToPeer::allreduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structraw__function.html">raw_function</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For associative and commutative functions, allreduce_no_order is called. Otherwise, reduce followed by bcast is used. </p>

<p>Reimplemented from <a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#a0b16b237e71e1f7e4b0f6f89b37539e8">FMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="a716d175a63e30ac982b85ea494e7b788" name="a716d175a63e30ac982b85ea494e7b788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716d175a63e30ac982b85ea494e7b788">&#9670;&nbsp;</a></span>allreduce_no_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FMI::Comm::PeerToPeer::allreduce_no_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structraw__function.html">raw_function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursive doubling allreduce implementation. When num_peers is not a power of two, there is an additional message in the beginning and end for every peer where they send their value / receive the reduced value. </p>

</div>
</div>
<a id="a20938de637594812abb4831ca0a4a412" name="a20938de637594812abb4831ca0a4a412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20938de637594812abb4831ca0a4a412">&#9670;&nbsp;</a></span>barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FMI::Comm::PeerToPeer::barrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls allreduce with a (associative and commutative) NOP operation. </p>

<p>Implements <a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#ab6a007b6f5b2f365322de624b3afa679">FMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="a7ebfb93838072c441366cf33969b4345" name="a7ebfb93838072c441366cf33969b4345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ebfb93838072c441366cf33969b4345">&#9670;&nbsp;</a></span>bcast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FMI::Comm::PeerToPeer::bcast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">FMI::Utils::peer_num</a>&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binomial tree broadcast implementation. </p>

<p>Implements <a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#aa0f3418bb68ad36861d5f577a4015cc3">FMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="a7bdac4f4b23f1be105e3caf3f8bbae8d" name="a7bdac4f4b23f1be105e3caf3f8bbae8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bdac4f4b23f1be105e3caf3f8bbae8d">&#9670;&nbsp;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FMI::Comm::PeerToPeer::gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">FMI::Utils::peer_num</a>&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binomial tree gather. </p>
<p >In the beginning, the needed buffer size (largest value that this peer will receive) is determined and a buffer is allocated. If the ID of the root is not 0, we cannot necessarily receive all values directly in recvbuf because we need to wrap around (e.g., when we get from peer N - 1 the values for N - 1, 0, and 1). This is solved by allocating a temporary buffer and copying the values. </p>

<p>Reimplemented from <a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#aa746e11c716ae2637f433881e85b0ef5">FMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="a00ebd572a8f14ee6335bf684bf121473" name="a00ebd572a8f14ee6335bf684bf121473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ebd572a8f14ee6335bf684bf121473">&#9670;&nbsp;</a></span>get_operation_latency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double FMI::Comm::PeerToPeer::get_operation_latency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_m_i_1_1_utils_1_1_operation_info.html">Utils::OperationInfo</a>&#160;</td>
          <td class="paramname"><em>op_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performance model for collective operations, provides the latency for the given operation. </p>

<p>Implements <a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#afb5b98f8a29bb8fc13a84e1019611658">FMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="ab93c5dde9ef79fbc03980fd883239e9b" name="ab93c5dde9ef79fbc03980fd883239e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93c5dde9ef79fbc03980fd883239e9b">&#9670;&nbsp;</a></span>get_operation_price()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double FMI::Comm::PeerToPeer::get_operation_price </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_f_m_i_1_1_utils_1_1_operation_info.html">Utils::OperationInfo</a>&#160;</td>
          <td class="paramname"><em>op_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cost model for collective operations, provides the price for the given operation. </p>

<p>Implements <a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#ad6cae9955817c1ceaa952bf7f6f06600">FMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="a1d28eb8d914a5598f11f829a0812c09f" name="a1d28eb8d914a5598f11f829a0812c09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d28eb8d914a5598f11f829a0812c09f">&#9670;&nbsp;</a></span>recv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FMI::Comm::PeerToPeer::recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">FMI::Utils::peer_num</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive data from peer with id src, must match a send call. </p>

<p>Implements <a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#a43e0f6e8be3dd115ca36185bec30ff08">FMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="acb95fe6dec31fecd90869e03c97b3698" name="acb95fe6dec31fecd90869e03c97b3698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb95fe6dec31fecd90869e03c97b3698">&#9670;&nbsp;</a></span>recv_object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FMI::Comm::PeerToPeer::recv_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">Utils::peer_num</a>&#160;</td>
          <td class="paramname"><em>peer_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive an object from peer with ID peer_id. Needs to be implemented by the channels. </p>

<p>Implemented in <a class="el" href="class_f_m_i_1_1_comm_1_1_direct.html#a6bee34d108685adb6f2dba6543f7d018">FMI::Comm::Direct</a>.</p>

</div>
</div>
<a id="a5964edc9ddf7e3b3586f5c79cf9bc317" name="a5964edc9ddf7e3b3586f5c79cf9bc317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5964edc9ddf7e3b3586f5c79cf9bc317">&#9670;&nbsp;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FMI::Comm::PeerToPeer::reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">FMI::Utils::peer_num</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structraw__function.html">raw_function</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls reduce_no_order for associative and commutative functions, reduce_ltr otherwise. </p>

<p>Implements <a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#a3ac53d8a255bb084de31488dd397e978">FMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="a4d05f0a04be2d7dcb966ea7714e1c243" name="a4d05f0a04be2d7dcb966ea7714e1c243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d05f0a04be2d7dcb966ea7714e1c243">&#9670;&nbsp;</a></span>reduce_ltr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FMI::Comm::PeerToPeer::reduce_ltr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">FMI::Utils::peer_num</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structraw__function.html">raw_function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduction with left-to-right evaluation, gather followed by a function evaluation on the root peer. </p>

</div>
</div>
<a id="a4869c382734a078c1c357536bee3f114" name="a4869c382734a078c1c357536bee3f114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4869c382734a078c1c357536bee3f114">&#9670;&nbsp;</a></span>reduce_no_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FMI::Comm::PeerToPeer::reduce_no_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">FMI::Utils::peer_num</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structraw__function.html">raw_function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binomial tree reduction where all peers apply the function in every step. </p>

</div>
</div>
<a id="a54911802d94b2913ac2d2f1c970e498d" name="a54911802d94b2913ac2d2f1c970e498d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54911802d94b2913ac2d2f1c970e498d">&#9670;&nbsp;</a></span>scan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FMI::Comm::PeerToPeer::scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structraw__function.html">raw_function</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For associative and commutative functions, scan_no_order is called. Otherwise, scan_ltr is called. </p>

<p>Implements <a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#aac096a0dd4d758d84bfc778185b2cb8f">FMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="aa110a201850ceabf4959fe77d0ec4a10" name="aa110a201850ceabf4959fe77d0ec4a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa110a201850ceabf4959fe77d0ec4a10">&#9670;&nbsp;</a></span>scan_ltr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FMI::Comm::PeerToPeer::scan_ltr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structraw__function.html">raw_function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linear function application / sending. </p>

</div>
</div>
<a id="a5a05ba40632ffc2328e9a01a33e7f373" name="a5a05ba40632ffc2328e9a01a33e7f373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a05ba40632ffc2328e9a01a33e7f373">&#9670;&nbsp;</a></span>scan_no_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FMI::Comm::PeerToPeer::scan_no_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structraw__function.html">raw_function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binomial tree with up- and down-phase. </p>

</div>
</div>
<a id="a2db2dfcf52658225c8539de30da0321f" name="a2db2dfcf52658225c8539de30da0321f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db2dfcf52658225c8539de30da0321f">&#9670;&nbsp;</a></span>scatter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FMI::Comm::PeerToPeer::scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">FMI::Utils::peer_num</a>&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binomial tree scatter. </p>
<p >Similarly to gather, the root may need to send values from its sendbuf that is not consecutive when its ID is not 0, which is solved with a temporary buffer. </p>

<p>Reimplemented from <a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#abb3a4f1443a1be062e75e911f3e5e892">FMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="a82903e6459ffa1ccf71af2cc67ca977f" name="a82903e6459ffa1ccf71af2cc67ca977f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82903e6459ffa1ccf71af2cc67ca977f">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void FMI::Comm::PeerToPeer::send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">FMI::Utils::peer_num</a>&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send data to peer with id dest, must match a recv call. </p>

<p>Implements <a class="el" href="class_f_m_i_1_1_comm_1_1_channel.html#a872d6b668a91c9d3cb993ef301cfdf04">FMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="a334549eda175c0ca0e5f7abbd45d7f1e" name="a334549eda175c0ca0e5f7abbd45d7f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334549eda175c0ca0e5f7abbd45d7f1e">&#9670;&nbsp;</a></span>send_object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void FMI::Comm::PeerToPeer::send_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_f_m_i_1_1_utils.html#add14eb01bf0abdaa4f594ef3a0ca66d0">Utils::peer_num</a>&#160;</td>
          <td class="paramname"><em>peer_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send an object to peer with ID peer_id. Needs to be implemented by the channels. </p>

<p>Implemented in <a class="el" href="class_f_m_i_1_1_comm_1_1_direct.html#adaecf336f8f2b81df6b29970dff93505">FMI::Comm::Direct</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/comm/<a class="el" href="_peer_to_peer_8h_source.html">PeerToPeer.h</a></li>
<li>src/comm/<a class="el" href="_peer_to_peer_8cpp.html">PeerToPeer.cpp</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>&copy; 2021 Roman Böhringer</small></address>
</body>
</html>