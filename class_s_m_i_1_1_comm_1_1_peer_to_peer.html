<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SMI: SMI::Comm::PeerToPeer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SMI<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">Serverless Message Interface</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_s_m_i.html">SMI</a></li><li class="navelem"><a class="el" href="namespace_s_m_i_1_1_comm.html">Comm</a></li><li class="navelem"><a class="el" href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html">PeerToPeer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_s_m_i_1_1_comm_1_1_peer_to_peer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SMI::Comm::PeerToPeer Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Peer-To-Peer channel type.  
 <a href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_peer_to_peer_8h_source.html">PeerToPeer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SMI::Comm::PeerToPeer:</div>
<div class="dyncontent">
<div class="center"><img src="class_s_m_i_1_1_comm_1_1_peer_to_peer__inherit__graph.png" border="0" usemap="#a_s_m_i_1_1_comm_1_1_peer_to_peer_inherit__map" alt="Inheritance graph"/></div>
<map name="a_s_m_i_1_1_comm_1_1_peer_to_peer_inherit__map" id="a_s_m_i_1_1_comm_1_1_peer_to_peer_inherit__map">
<area shape="rect" title="Peer&#45;To&#45;Peer channel type." alt="" coords="5,321,179,648"/>
<area shape="rect" href="class_s_m_i_1_1_comm_1_1_direct.html" title="Channel that uses the TCPunch TCP NAT Hole Punching Library for connection establishment." alt="" coords="25,696,159,832"/>
<area shape="rect" href="class_s_m_i_1_1_comm_1_1_channel.html" title="Interface that defines channel operations. Only provides a few default implementations,..." alt="" coords="17,5,167,273"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for SMI::Comm::PeerToPeer:</div>
<div class="dyncontent">
<div class="center"><img src="class_s_m_i_1_1_comm_1_1_peer_to_peer__coll__graph.png" border="0" usemap="#a_s_m_i_1_1_comm_1_1_peer_to_peer_coll__map" alt="Collaboration graph"/></div>
<map name="a_s_m_i_1_1_comm_1_1_peer_to_peer_coll__map" id="a_s_m_i_1_1_comm_1_1_peer_to_peer_coll__map">
<area shape="rect" title="Peer&#45;To&#45;Peer channel type." alt="" coords="20,448,193,775"/>
<area shape="rect" href="class_s_m_i_1_1_comm_1_1_channel.html" title="Interface that defines channel operations. Only provides a few default implementations,..." alt="" coords="32,160,181,399"/>
<area shape="rect" title=" " alt="" coords="5,5,99,83"/>
<area shape="rect" title=" " alt="" coords="134,5,189,83"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a412842c960615ec16e09643d2706d437"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a412842c960615ec16e09643d2706d437">send</a> (<a class="el" href="structchannel__data.html">channel_data</a> buf, <a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">SMI::Utils::peer_num</a> dest) override</td></tr>
<tr class="memdesc:a412842c960615ec16e09643d2706d437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data to peer with id dest, must match a recv call.  <a href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a412842c960615ec16e09643d2706d437">More...</a><br /></td></tr>
<tr class="separator:a412842c960615ec16e09643d2706d437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7457036d22cb4caa4e9c73d70943dbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#ae7457036d22cb4caa4e9c73d70943dbf">recv</a> (<a class="el" href="structchannel__data.html">channel_data</a> buf, <a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">SMI::Utils::peer_num</a> src) override</td></tr>
<tr class="memdesc:ae7457036d22cb4caa4e9c73d70943dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive data from peer with id src, must match a send call.  <a href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#ae7457036d22cb4caa4e9c73d70943dbf">More...</a><br /></td></tr>
<tr class="separator:ae7457036d22cb4caa4e9c73d70943dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1e3f3d23f26018d93883fa81f7f527"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#afe1e3f3d23f26018d93883fa81f7f527">bcast</a> (<a class="el" href="structchannel__data.html">channel_data</a> buf, <a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">SMI::Utils::peer_num</a> root) override</td></tr>
<tr class="memdesc:afe1e3f3d23f26018d93883fa81f7f527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binomial tree broadcast implementation.  <a href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#afe1e3f3d23f26018d93883fa81f7f527">More...</a><br /></td></tr>
<tr class="separator:afe1e3f3d23f26018d93883fa81f7f527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ab65cf137d78a8a29548a7d99e4ed0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#ae3ab65cf137d78a8a29548a7d99e4ed0">barrier</a> () override</td></tr>
<tr class="memdesc:ae3ab65cf137d78a8a29548a7d99e4ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls allreduce with a (associative and commutative) NOP operation.  <a href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#ae3ab65cf137d78a8a29548a7d99e4ed0">More...</a><br /></td></tr>
<tr class="separator:ae3ab65cf137d78a8a29548a7d99e4ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9607cf071d57ad22ec6a82b80733acbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a9607cf071d57ad22ec6a82b80733acbe">gather</a> (<a class="el" href="structchannel__data.html">channel_data</a> sendbuf, <a class="el" href="structchannel__data.html">channel_data</a> recvbuf, <a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">SMI::Utils::peer_num</a> root) override</td></tr>
<tr class="memdesc:a9607cf071d57ad22ec6a82b80733acbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binomial tree gather.  <a href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a9607cf071d57ad22ec6a82b80733acbe">More...</a><br /></td></tr>
<tr class="separator:a9607cf071d57ad22ec6a82b80733acbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f468059140c3711115859ce27bbb6bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a3f468059140c3711115859ce27bbb6bf">scatter</a> (<a class="el" href="structchannel__data.html">channel_data</a> sendbuf, <a class="el" href="structchannel__data.html">channel_data</a> recvbuf, <a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">SMI::Utils::peer_num</a> root) override</td></tr>
<tr class="memdesc:a3f468059140c3711115859ce27bbb6bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binomial tree scatter.  <a href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a3f468059140c3711115859ce27bbb6bf">More...</a><br /></td></tr>
<tr class="separator:a3f468059140c3711115859ce27bbb6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c11aba41c2479ff8d2cfe3cf8b5adc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a8c11aba41c2479ff8d2cfe3cf8b5adc8">reduce</a> (<a class="el" href="structchannel__data.html">channel_data</a> sendbuf, <a class="el" href="structchannel__data.html">channel_data</a> recvbuf, <a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">SMI::Utils::peer_num</a> root, <a class="el" href="structraw__function.html">raw_function</a> f) override</td></tr>
<tr class="memdesc:a8c11aba41c2479ff8d2cfe3cf8b5adc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls reduce_no_order for associative and commutative functions, reduce_ltr otherwise.  <a href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a8c11aba41c2479ff8d2cfe3cf8b5adc8">More...</a><br /></td></tr>
<tr class="separator:a8c11aba41c2479ff8d2cfe3cf8b5adc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4166601090af39027875b31b860e83b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a4166601090af39027875b31b860e83b1">allreduce</a> (<a class="el" href="structchannel__data.html">channel_data</a> sendbuf, <a class="el" href="structchannel__data.html">channel_data</a> recvbuf, <a class="el" href="structraw__function.html">raw_function</a> f) override</td></tr>
<tr class="memdesc:a4166601090af39027875b31b860e83b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">For associative and commutative functions, allreduce_no_order is called. Otherwise, reduce followed by bcast is used.  <a href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a4166601090af39027875b31b860e83b1">More...</a><br /></td></tr>
<tr class="separator:a4166601090af39027875b31b860e83b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1f6a73c7817e5a1fe17785ecd4d101"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a7d1f6a73c7817e5a1fe17785ecd4d101">scan</a> (<a class="el" href="structchannel__data.html">channel_data</a> sendbuf, <a class="el" href="structchannel__data.html">channel_data</a> recvbuf, <a class="el" href="structraw__function.html">raw_function</a> f) override</td></tr>
<tr class="memdesc:a7d1f6a73c7817e5a1fe17785ecd4d101"><td class="mdescLeft">&#160;</td><td class="mdescRight">For associative and commutative functions, scan_no_order is called. Otherwise, scan_ltr is called.  <a href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a7d1f6a73c7817e5a1fe17785ecd4d101">More...</a><br /></td></tr>
<tr class="separator:a7d1f6a73c7817e5a1fe17785ecd4d101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2102f0878fcad3fd3f69c0a1569e70ab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a2102f0878fcad3fd3f69c0a1569e70ab">send_object</a> (<a class="el" href="structchannel__data.html">channel_data</a> buf, <a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">Utils::peer_num</a> <a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#a731422d39c639bddb43c0a27ebd064a4">peer_id</a>)=0</td></tr>
<tr class="memdesc:a2102f0878fcad3fd3f69c0a1569e70ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send an object to peer with ID peer_id. Needs to be implemented by the channels.  <a href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a2102f0878fcad3fd3f69c0a1569e70ab">More...</a><br /></td></tr>
<tr class="separator:a2102f0878fcad3fd3f69c0a1569e70ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bae27756b2e39ab318b81f7fcc9bb3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#ab8bae27756b2e39ab318b81f7fcc9bb3">recv_object</a> (<a class="el" href="structchannel__data.html">channel_data</a> buf, <a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">Utils::peer_num</a> <a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#a731422d39c639bddb43c0a27ebd064a4">peer_id</a>)=0</td></tr>
<tr class="memdesc:ab8bae27756b2e39ab318b81f7fcc9bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive an object from peer with ID peer_id. Needs to be implemented by the channels.  <a href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#ab8bae27756b2e39ab318b81f7fcc9bb3">More...</a><br /></td></tr>
<tr class="separator:ab8bae27756b2e39ab318b81f7fcc9bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a1586c95f53668c84381662323eedb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#ae3a1586c95f53668c84381662323eedb">get_operation_latency</a> (<a class="el" href="struct_s_m_i_1_1_utils_1_1_operation_info.html">Utils::OperationInfo</a> op_info) override</td></tr>
<tr class="memdesc:ae3a1586c95f53668c84381662323eedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performance model for collective operations, provides the latency for the given operation.  <a href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#ae3a1586c95f53668c84381662323eedb">More...</a><br /></td></tr>
<tr class="separator:ae3a1586c95f53668c84381662323eedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091575f8bd476fda533fa9691e321da8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a091575f8bd476fda533fa9691e321da8">get_operation_price</a> (<a class="el" href="struct_s_m_i_1_1_utils_1_1_operation_info.html">Utils::OperationInfo</a> op_info) override</td></tr>
<tr class="memdesc:a091575f8bd476fda533fa9691e321da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost model for collective operations, provides the price for the given operation.  <a href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a091575f8bd476fda533fa9691e321da8">More...</a><br /></td></tr>
<tr class="separator:a091575f8bd476fda533fa9691e321da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_s_m_i_1_1_comm_1_1_channel"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_s_m_i_1_1_comm_1_1_channel')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html">SMI::Comm::Channel</a></td></tr>
<tr class="memitem:ae15209fbc3f9faae34f544fa0d82a9f6 inherit pub_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#ae15209fbc3f9faae34f544fa0d82a9f6">set_peer_id</a> (<a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">SMI::Utils::peer_num</a> num)</td></tr>
<tr class="memdesc:ae15209fbc3f9faae34f544fa0d82a9f6 inherit pub_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to set peer id, ID needs to be set before first collective operation.  <a href="class_s_m_i_1_1_comm_1_1_channel.html#ae15209fbc3f9faae34f544fa0d82a9f6">More...</a><br /></td></tr>
<tr class="separator:ae15209fbc3f9faae34f544fa0d82a9f6 inherit pub_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab69d873513e2a1aaa57f85b6deb6c5c inherit pub_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#aab69d873513e2a1aaa57f85b6deb6c5c">set_num_peers</a> (<a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">SMI::Utils::peer_num</a> num)</td></tr>
<tr class="memdesc:aab69d873513e2a1aaa57f85b6deb6c5c inherit pub_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to set number of peers, needs to be set before first collective operation.  <a href="class_s_m_i_1_1_comm_1_1_channel.html#aab69d873513e2a1aaa57f85b6deb6c5c">More...</a><br /></td></tr>
<tr class="separator:aab69d873513e2a1aaa57f85b6deb6c5c inherit pub_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd35018b091f7ff7cb920307ed8e1b8 inherit pub_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#a1fd35018b091f7ff7cb920307ed8e1b8">set_comm_name</a> (std::string communication_name)</td></tr>
<tr class="memdesc:a1fd35018b091f7ff7cb920307ed8e1b8 inherit pub_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper utility to set the communicator name, should be set before first collective operation to avoid conflicts with empty communicator name.  <a href="class_s_m_i_1_1_comm_1_1_channel.html#a1fd35018b091f7ff7cb920307ed8e1b8">More...</a><br /></td></tr>
<tr class="separator:a1fd35018b091f7ff7cb920307ed8e1b8 inherit pub_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a03f410651f99dece782970bb29172 inherit pub_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#a41a03f410651f99dece782970bb29172">finalize</a> ()</td></tr>
<tr class="memdesc:a41a03f410651f99dece782970bb29172 inherit pub_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before communicator is destructed, can be used by channels to clean up (e.g., delete resources)  <a href="class_s_m_i_1_1_comm_1_1_channel.html#a41a03f410651f99dece782970bb29172">More...</a><br /></td></tr>
<tr class="separator:a41a03f410651f99dece782970bb29172 inherit pub_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3269f7677a01a9294733231c308076e inherit pub_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#aa3269f7677a01a9294733231c308076e">get_latency</a> (<a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">Utils::peer_num</a> producer, <a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">Utils::peer_num</a> consumer, std::size_t size_in_bytes)=0</td></tr>
<tr class="memdesc:aa3269f7677a01a9294733231c308076e inherit pub_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performance model of an individual channel, provides latency for a simple exchange with a number of producers / consumers.  <a href="class_s_m_i_1_1_comm_1_1_channel.html#aa3269f7677a01a9294733231c308076e">More...</a><br /></td></tr>
<tr class="separator:aa3269f7677a01a9294733231c308076e inherit pub_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca25b4aba8035def8974d1ac56acf92c inherit pub_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#aca25b4aba8035def8974d1ac56acf92c">get_price</a> (<a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">Utils::peer_num</a> producer, <a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">Utils::peer_num</a> consumer, std::size_t size_in_bytes)=0</td></tr>
<tr class="memdesc:aca25b4aba8035def8974d1ac56acf92c inherit pub_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost model of an individual channel, provides price for a simple exchange with a number of producers / consumers.  <a href="class_s_m_i_1_1_comm_1_1_channel.html#aca25b4aba8035def8974d1ac56acf92c">More...</a><br /></td></tr>
<tr class="separator:aca25b4aba8035def8974d1ac56acf92c inherit pub_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af3ba58924b6948ce80eba386ef256376"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#af3ba58924b6948ce80eba386ef256376">reduce_ltr</a> (<a class="el" href="structchannel__data.html">channel_data</a> sendbuf, <a class="el" href="structchannel__data.html">channel_data</a> recvbuf, <a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">SMI::Utils::peer_num</a> root, const <a class="el" href="structraw__function.html">raw_function</a> &amp;f)</td></tr>
<tr class="memdesc:af3ba58924b6948ce80eba386ef256376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduction with left-to-right evaluation, gather followed by a function evaluation on the root peer.  <a href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#af3ba58924b6948ce80eba386ef256376">More...</a><br /></td></tr>
<tr class="separator:af3ba58924b6948ce80eba386ef256376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62200f0f0c932eb743963274dc24e477"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a62200f0f0c932eb743963274dc24e477">reduce_no_order</a> (<a class="el" href="structchannel__data.html">channel_data</a> sendbuf, <a class="el" href="structchannel__data.html">channel_data</a> recvbuf, <a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">SMI::Utils::peer_num</a> root, const <a class="el" href="structraw__function.html">raw_function</a> &amp;f)</td></tr>
<tr class="memdesc:a62200f0f0c932eb743963274dc24e477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binomial tree reduction where all peers apply the function in every step.  <a href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a62200f0f0c932eb743963274dc24e477">More...</a><br /></td></tr>
<tr class="separator:a62200f0f0c932eb743963274dc24e477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ef656ea129ab4c0c3b83ac6b393a1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a25ef656ea129ab4c0c3b83ac6b393a1b">allreduce_no_order</a> (<a class="el" href="structchannel__data.html">channel_data</a> sendbuf, <a class="el" href="structchannel__data.html">channel_data</a> recvbuf, const <a class="el" href="structraw__function.html">raw_function</a> &amp;f)</td></tr>
<tr class="memdesc:a25ef656ea129ab4c0c3b83ac6b393a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive doubling allreduce implementation. When num_peers is not a power of two, there is an additional message in the beginning and end for every peer where they send their value / receive the reduced value.  <a href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a25ef656ea129ab4c0c3b83ac6b393a1b">More...</a><br /></td></tr>
<tr class="separator:a25ef656ea129ab4c0c3b83ac6b393a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d51574e1a97a6ead844ba95f9026f87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a4d51574e1a97a6ead844ba95f9026f87">scan_ltr</a> (<a class="el" href="structchannel__data.html">channel_data</a> sendbuf, <a class="el" href="structchannel__data.html">channel_data</a> recvbuf, const <a class="el" href="structraw__function.html">raw_function</a> &amp;f)</td></tr>
<tr class="memdesc:a4d51574e1a97a6ead844ba95f9026f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear function application / sending.  <a href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a4d51574e1a97a6ead844ba95f9026f87">More...</a><br /></td></tr>
<tr class="separator:a4d51574e1a97a6ead844ba95f9026f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1794950bceadbada93b40a608487092a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a1794950bceadbada93b40a608487092a">scan_no_order</a> (<a class="el" href="structchannel__data.html">channel_data</a> sendbuf, <a class="el" href="structchannel__data.html">channel_data</a> recvbuf, const <a class="el" href="structraw__function.html">raw_function</a> &amp;f)</td></tr>
<tr class="memdesc:a1794950bceadbada93b40a608487092a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binomial tree with up- and down-phase.  <a href="class_s_m_i_1_1_comm_1_1_peer_to_peer.html#a1794950bceadbada93b40a608487092a">More...</a><br /></td></tr>
<tr class="separator:a1794950bceadbada93b40a608487092a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_class_s_m_i_1_1_comm_1_1_channel"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_s_m_i_1_1_comm_1_1_channel')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html">SMI::Comm::Channel</a></td></tr>
<tr class="memitem:a25b31541657da4b88dd9457935e53371 inherit pub_static_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html">Channel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#a25b31541657da4b88dd9457935e53371">get_channel</a> (std::string name, std::map&lt; std::string, std::string &gt; params, std::map&lt; std::string, std::string &gt; model_params)</td></tr>
<tr class="memdesc:a25b31541657da4b88dd9457935e53371 inherit pub_static_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new channel with the given config and model params.  <a href="class_s_m_i_1_1_comm_1_1_channel.html#a25b31541657da4b88dd9457935e53371">More...</a><br /></td></tr>
<tr class="separator:a25b31541657da4b88dd9457935e53371 inherit pub_static_methods_class_s_m_i_1_1_comm_1_1_channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_s_m_i_1_1_comm_1_1_channel"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_s_m_i_1_1_comm_1_1_channel')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html">SMI::Comm::Channel</a></td></tr>
<tr class="memitem:a731422d39c639bddb43c0a27ebd064a4 inherit pro_attribs_class_s_m_i_1_1_comm_1_1_channel"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">SMI::Utils::peer_num</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#a731422d39c639bddb43c0a27ebd064a4">peer_id</a></td></tr>
<tr class="separator:a731422d39c639bddb43c0a27ebd064a4 inherit pro_attribs_class_s_m_i_1_1_comm_1_1_channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6b8ef08d22fb3031f8837373d82e38 inherit pro_attribs_class_s_m_i_1_1_comm_1_1_channel"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">SMI::Utils::peer_num</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#aff6b8ef08d22fb3031f8837373d82e38">num_peers</a></td></tr>
<tr class="separator:aff6b8ef08d22fb3031f8837373d82e38 inherit pro_attribs_class_s_m_i_1_1_comm_1_1_channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6a19fe4deb2038b878a07870b92a97 inherit pro_attribs_class_s_m_i_1_1_comm_1_1_channel"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#a5c6a19fe4deb2038b878a07870b92a97">comm_name</a></td></tr>
<tr class="memdesc:a5c6a19fe4deb2038b878a07870b92a97 inherit pro_attribs_class_s_m_i_1_1_comm_1_1_channel"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can optionally be used by channels to avoid resource conflicts that may occur because of multiple concurrent communicators.  <a href="class_s_m_i_1_1_comm_1_1_channel.html#a5c6a19fe4deb2038b878a07870b92a97">More...</a><br /></td></tr>
<tr class="separator:a5c6a19fe4deb2038b878a07870b92a97 inherit pro_attribs_class_s_m_i_1_1_comm_1_1_channel"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Peer-To-Peer channel type. </p>
<p >This class provides optimized collectives for channels where clients can address each other directly and defines the interface that these channels need to implement. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a4166601090af39027875b31b860e83b1" name="a4166601090af39027875b31b860e83b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4166601090af39027875b31b860e83b1">&#9670;&nbsp;</a></span>allreduce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SMI::Comm::PeerToPeer::allreduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structraw__function.html">raw_function</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For associative and commutative functions, allreduce_no_order is called. Otherwise, reduce followed by bcast is used. </p>

<p>Reimplemented from <a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#aee4169d238928515d3845bfe27386f5e">SMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="a25ef656ea129ab4c0c3b83ac6b393a1b" name="a25ef656ea129ab4c0c3b83ac6b393a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ef656ea129ab4c0c3b83ac6b393a1b">&#9670;&nbsp;</a></span>allreduce_no_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SMI::Comm::PeerToPeer::allreduce_no_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structraw__function.html">raw_function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursive doubling allreduce implementation. When num_peers is not a power of two, there is an additional message in the beginning and end for every peer where they send their value / receive the reduced value. </p>

</div>
</div>
<a id="ae3ab65cf137d78a8a29548a7d99e4ed0" name="ae3ab65cf137d78a8a29548a7d99e4ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ab65cf137d78a8a29548a7d99e4ed0">&#9670;&nbsp;</a></span>barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SMI::Comm::PeerToPeer::barrier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls allreduce with a (associative and commutative) NOP operation. </p>

<p>Implements <a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#a1af086381ff01ce5da9eb76244132103">SMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="afe1e3f3d23f26018d93883fa81f7f527" name="afe1e3f3d23f26018d93883fa81f7f527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1e3f3d23f26018d93883fa81f7f527">&#9670;&nbsp;</a></span>bcast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SMI::Comm::PeerToPeer::bcast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">SMI::Utils::peer_num</a>&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binomial tree broadcast implementation. </p>

<p>Implements <a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#a6fbfd798071974ae9f24240a7bad8d49">SMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="a9607cf071d57ad22ec6a82b80733acbe" name="a9607cf071d57ad22ec6a82b80733acbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9607cf071d57ad22ec6a82b80733acbe">&#9670;&nbsp;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SMI::Comm::PeerToPeer::gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">SMI::Utils::peer_num</a>&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binomial tree gather. </p>
<p >In the beginning, the needed buffer size (largest value that this peer will receive) is determined and a buffer is allocated. If the ID of the root is not 0, we cannot necessarily receive all values directly in recvbuf because we need to wrap around (e.g., when we get from peer N - 1 the values for N - 1, 0, and 1). This is solved by allocating a temporary buffer and copying the values. </p>

<p>Reimplemented from <a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#abea5a99cddb1afcb531d93e87b367e05">SMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="ae3a1586c95f53668c84381662323eedb" name="ae3a1586c95f53668c84381662323eedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a1586c95f53668c84381662323eedb">&#9670;&nbsp;</a></span>get_operation_latency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SMI::Comm::PeerToPeer::get_operation_latency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_1_1_utils_1_1_operation_info.html">Utils::OperationInfo</a>&#160;</td>
          <td class="paramname"><em>op_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performance model for collective operations, provides the latency for the given operation. </p>

<p>Implements <a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#a5cd04356280dc3c1d61a2b647891f5c4">SMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="a091575f8bd476fda533fa9691e321da8" name="a091575f8bd476fda533fa9691e321da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091575f8bd476fda533fa9691e321da8">&#9670;&nbsp;</a></span>get_operation_price()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double SMI::Comm::PeerToPeer::get_operation_price </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_s_m_i_1_1_utils_1_1_operation_info.html">Utils::OperationInfo</a>&#160;</td>
          <td class="paramname"><em>op_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cost model for collective operations, provides the price for the given operation. </p>

<p>Implements <a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#a096059811704436efbabc4a819c648e0">SMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="ae7457036d22cb4caa4e9c73d70943dbf" name="ae7457036d22cb4caa4e9c73d70943dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7457036d22cb4caa4e9c73d70943dbf">&#9670;&nbsp;</a></span>recv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SMI::Comm::PeerToPeer::recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">SMI::Utils::peer_num</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive data from peer with id src, must match a send call. </p>

<p>Implements <a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#a77b1679c653ac5b9827cc5c3fbcacd1f">SMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="ab8bae27756b2e39ab318b81f7fcc9bb3" name="ab8bae27756b2e39ab318b81f7fcc9bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8bae27756b2e39ab318b81f7fcc9bb3">&#9670;&nbsp;</a></span>recv_object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SMI::Comm::PeerToPeer::recv_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">Utils::peer_num</a>&#160;</td>
          <td class="paramname"><em>peer_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive an object from peer with ID peer_id. Needs to be implemented by the channels. </p>

<p>Implemented in <a class="el" href="class_s_m_i_1_1_comm_1_1_direct.html#a5638f2b571c41725f6eefb46fba32c46">SMI::Comm::Direct</a>.</p>

</div>
</div>
<a id="a8c11aba41c2479ff8d2cfe3cf8b5adc8" name="a8c11aba41c2479ff8d2cfe3cf8b5adc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c11aba41c2479ff8d2cfe3cf8b5adc8">&#9670;&nbsp;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SMI::Comm::PeerToPeer::reduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">SMI::Utils::peer_num</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structraw__function.html">raw_function</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls reduce_no_order for associative and commutative functions, reduce_ltr otherwise. </p>

<p>Implements <a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#aeb66931eae096f4906a863dbdab97d86">SMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="af3ba58924b6948ce80eba386ef256376" name="af3ba58924b6948ce80eba386ef256376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ba58924b6948ce80eba386ef256376">&#9670;&nbsp;</a></span>reduce_ltr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SMI::Comm::PeerToPeer::reduce_ltr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">SMI::Utils::peer_num</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structraw__function.html">raw_function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduction with left-to-right evaluation, gather followed by a function evaluation on the root peer. </p>

</div>
</div>
<a id="a62200f0f0c932eb743963274dc24e477" name="a62200f0f0c932eb743963274dc24e477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62200f0f0c932eb743963274dc24e477">&#9670;&nbsp;</a></span>reduce_no_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SMI::Comm::PeerToPeer::reduce_no_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">SMI::Utils::peer_num</a>&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structraw__function.html">raw_function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binomial tree reduction where all peers apply the function in every step. </p>

</div>
</div>
<a id="a7d1f6a73c7817e5a1fe17785ecd4d101" name="a7d1f6a73c7817e5a1fe17785ecd4d101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1f6a73c7817e5a1fe17785ecd4d101">&#9670;&nbsp;</a></span>scan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SMI::Comm::PeerToPeer::scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structraw__function.html">raw_function</a>&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For associative and commutative functions, scan_no_order is called. Otherwise, scan_ltr is called. </p>

<p>Implements <a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#a6ef763a1c2c07faa953e564505fc5646">SMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="a4d51574e1a97a6ead844ba95f9026f87" name="a4d51574e1a97a6ead844ba95f9026f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d51574e1a97a6ead844ba95f9026f87">&#9670;&nbsp;</a></span>scan_ltr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SMI::Comm::PeerToPeer::scan_ltr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structraw__function.html">raw_function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linear function application / sending. </p>

</div>
</div>
<a id="a1794950bceadbada93b40a608487092a" name="a1794950bceadbada93b40a608487092a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1794950bceadbada93b40a608487092a">&#9670;&nbsp;</a></span>scan_no_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SMI::Comm::PeerToPeer::scan_no_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structraw__function.html">raw_function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binomial tree with up- and down-phase. </p>

</div>
</div>
<a id="a3f468059140c3711115859ce27bbb6bf" name="a3f468059140c3711115859ce27bbb6bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f468059140c3711115859ce27bbb6bf">&#9670;&nbsp;</a></span>scatter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SMI::Comm::PeerToPeer::scatter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>sendbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>recvbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">SMI::Utils::peer_num</a>&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binomial tree scatter. </p>
<p >Similarly to gather, the root may need to send values from its sendbuf that is not consecutive when its ID is not 0, which is solved with a temporary buffer. </p>

<p>Reimplemented from <a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#aed177a7ae2b25641b3618241b6d94d36">SMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="a412842c960615ec16e09643d2706d437" name="a412842c960615ec16e09643d2706d437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a412842c960615ec16e09643d2706d437">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SMI::Comm::PeerToPeer::send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">SMI::Utils::peer_num</a>&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send data to peer with id dest, must match a recv call. </p>

<p>Implements <a class="el" href="class_s_m_i_1_1_comm_1_1_channel.html#a2e56bbb37fe73a5e2aa954adf36a31c7">SMI::Comm::Channel</a>.</p>

</div>
</div>
<a id="a2102f0878fcad3fd3f69c0a1569e70ab" name="a2102f0878fcad3fd3f69c0a1569e70ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2102f0878fcad3fd3f69c0a1569e70ab">&#9670;&nbsp;</a></span>send_object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SMI::Comm::PeerToPeer::send_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structchannel__data.html">channel_data</a>&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_s_m_i_1_1_utils.html#a33529e5936ca78fdce4403a279ef4bb4">Utils::peer_num</a>&#160;</td>
          <td class="paramname"><em>peer_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send an object to peer with ID peer_id. Needs to be implemented by the channels. </p>

<p>Implemented in <a class="el" href="class_s_m_i_1_1_comm_1_1_direct.html#a592626ef19ced4cdac612ac3a472b7d1">SMI::Comm::Direct</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/comm/<a class="el" href="_peer_to_peer_8h_source.html">PeerToPeer.h</a></li>
<li>src/comm/<a class="el" href="_peer_to_peer_8cpp.html">PeerToPeer.cpp</a></li>
</ul>
</div><!-- contents -->
<hr class="footer"/><address class="footer"><small>&copy; 2021 Roman Böhringer</small></address>
</body>
</html>